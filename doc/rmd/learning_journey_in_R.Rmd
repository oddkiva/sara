# Learning Journey in R

The real motivation that made me want to learn about R is because of the R
*bookdown* package [@xie:2020:bookdown], [@xie:2021:bookdown]. Compared to
Sphinx documentation, This package is stunning in terms of:

1. pretty default yet customizable aesthetics (*gitbook* !),
2. smooth and natural LaTeX support,
3. and most of all *multilanguage capabilities*, particularly C++^[C++ support is
   done via Rcpp [@eddelbuettel:2018:rcpp]. While this is not a panacea, it is
   more than sufficient for demonstration purposes in this book. In particular,
   *Eigen* [@eigenweb] is supported by the existing package *RcppEigen*
   [@eddelbuettel:2013:rcppeigen]] and Python to support and check my writings
   with *correct* and *testable* code.

So much that it pushed me to port my initial Sphinx documentation into this
technology without further ado.

With feelings of both excitement and frustration as a newbie, it took me a few
days to experiment and frantically port the documentation by finding the useful
information bits gleaned here and there in StackOverflow, GitHub and elsewhere
instead of the original documentation.

Namely *bookdown* implements *literate programming*, a term coined by
[@knuth:1984:lp].

Shortly after I investigated if there are any Python alternative and just learnt
about *jupyter-book* (https://jupyterbook.org) is also available. However it is
not yet clear to me whether it has multilanguage support as good as in bookdown.
So I will stick with bookdown for now.

## Code

Here is a list of toy code examples I found online and which I tested myself.
They are copy-pasted here so that I don't google them again. You can copy-paste
them and then experiment on your own.

### R code snippet

Just like a Python notebook, R markdown allows us to write code and break it
down into multiple chunks and evaluate them as you are writing the report.

```{r}
x <- 5  # radius of a circle
```
The R markdown report you are writing has a state, so the variable `x` written
above can be reused and evaluated in the sequel.

So for a circle with radius `r x`, its area is `r pi * x^2`.

### Bash example

```{bash}
echo "Hello Bash!"
```

### C++ code

This is the language I care the most about since it is my primary language.

- Make sure that some packages are installed, without trying to be exhaustive,
  since I am currently learning myself. Specifically on the R console:

  ```{r, eval = FALSE}
  install.packages("Rcpp")
  install.packages("RcppEigen")
  ```

- Create your C++ compile environment by creating the file `~/.R/Makevars`.

  ```
  CXXFLAGS=-std-c++17 -I/path/to/my/favorite/libraries  # etc.
  ```
  Here I just want to make sure that C++ 17 is activated.

Let us see the following example in action.

```{Rcpp, cache=TRUE}

#include <iostream>
#include <utility>
#include <string>

#include <Rcpp.h>

// [[Rcpp::plugins(cpp17)]

// [[Rcpp::export]]
int fibonacci(int x)
{
  const auto [a, b] = std::make_pair(0, 1);
  if (x == 0 || x == 1)
    return x;
  return fibonacci(x-1) + fibonacci(x-2);
}

// [[Rcpp::export]]
Rcpp::String hello_me()
{
  return Rcpp::String("hello");
}
```

```{r}
fibonacci(10L)
hello_me()
```

One caveat worth noting is that as documented in the web Rcpp does not support
*trailing return types* which I very much prefer using because of its
aesthetics.

```{Rcpp, eval = FALSE}
// Rcpp is not able to compile this code :(

// [[Rcpp::export]]
auto square(int x) -> int
{
  return x * x;
}
```

### Python Code Snippet

```{python}
from matplotlib import pyplot as plt
from matplotlib.ticker import MultipleLocator
import numpy as np

# Two example plots
fig = plt.figure()
ax1 = fig.add_subplot(2,2,1)
ax2 = fig.add_subplot(2,2,2)

spacing = 0.5 # This can be your user specified spacing.
minorLocator = MultipleLocator(spacing)
ax1.plot(9 * np.random.rand(10))
# Set minor tick locations.
ax1.yaxis.set_minor_locator(minorLocator)
ax1.xaxis.set_minor_locator(minorLocator)
# Set grid to use minor tick locations.
ax1.grid(which = 'minor')

spacing = 1
minorLocator = MultipleLocator(spacing)
ax2.plot(9 * np.random.rand(10))
# Set minor tick locations.
ax2.yaxis.set_minor_locator(minorLocator)
ax2.xaxis.set_minor_locator(minorLocator)
# Set grid to use minor tick locations.
ax2.grid(which = 'minor')
plt.show()
```

## Visual Communication

I am mostly interested in making drawing to better convey my messages in my
writings. And one question came into my mind: can we do things quickly and
elegantly instead of matplotlib [@hunter:2007:matplotlib]? After all, we are in
the realm of R.

Let us start with a mini project: make additional drawings to improve the
section about SIFT (section \@ref(sift)).

### Mini-Project: Drawings for the SIFT Section

There is a lot of mathematics in this section \@ref(sift) that could be
supported with more drawings to better convey my messages. For one thing, I
write quite a bit about the geometry of overlapping patches with formula and
only provides formula but no drawings.  So if I were a reader of the book, I
would probably have a "meh" reaction and not try to understand them at all.

#### Starting Point

I found the following code example at
https://stat.ethz.ch/R-manual/R-devel/library/graphics/html/rect.html.

Since I am writing a book here, we can just serve the book with the following
command in the R console:

```{r, eval = FALSE}
bookdown::serve_book()
```

Let us copy-paste the code into an existing Rmd file and see it running in
action:

```{r}
require(grDevices)
## set up the plot region:
op <- par(bg = "thistle")
plot(c(100, 250), c(300, 450), type = "n", xlab = "", ylab = "",
     main = "2 x 11 rectangles; 'rect(100+i,300+i,  150+i,380+i)'")
i <- 4*(0:10)
## draw rectangles with bottom left (100, 300)+i
## and top right (150, 380)+i
rect(100+i, 300+i, 150+i, 380+i, col = rainbow(11, start = 0.7, end = 0.1))
rect(240-i, 320+i, 250-i, 410+i, col = heat.colors(11), lwd = i/5)
## Background alternating  ( transparent / "bg" ) :
j <- 10*(0:5)
rect(125+j, 360+j,   141+j, 405+j/2, col = c(NA,0),
     border = "gold", lwd = 2)
rect(125+j, 296+j/2, 141+j, 331+j/5, col = c(NA,"midnightblue"))
mtext("+  2 x 6 rect(*, col = c(NA,0)) and  col = c(NA,\"m..blue\")")

## an example showing colouring and shading
plot(c(100, 200), c(300, 450), type= "n", xlab = "", ylab = "")
rect(100, 300, 125, 350) # transparent
rect(100, 400, 125, 450, col = "green", border = "blue") # coloured
rect(115, 375, 150, 425, col = par("bg"), border = "transparent")
rect(150, 300, 175, 350, density = 10, border = "red")
rect(150, 400, 175, 450, density = 30, col = "blue",
     angle = -30, border = "transparent")

legend(180, 450, legend = 1:4, fill = c(NA, "green", par("fg"), "blue"),
       density = c(NA, NA, 10, 30), angle = c(NA, NA, 30, -30))

par(op)

```

#### Breaking Down the Example

Great! this code is working but there is too much information for somebody who
currently knows nothing about R and the aesthetics is awful.

Let's take it slow and simplify the code to the bare minimum, with a few things
that we experiment.

- https://www.r-bloggers.com/2017/10/loading-r-packages-library-or-require/
  recommends `library(.)` instead of `require(.)` as it makes the program easier
  to debug. So be it:

  ```{r}
  library(grDevices)
  ```

- We want to render the region defined by its bounding box. The parameter
  `type=n` apparently makes sure that the canvas is blank. The remaining
  parameters are legends.

  ```{r}
  # Let's try another background color.
  op <- par(bg = "#bfd8d8")

  # The region to render.
  x_domain <- c(100, 250)
  y_domain <- c(300, 450)
  plot(x_domain, y_domain, type = "n", xlab = "", ylab = "",
       main = "Main title: One Rectangle")

  # I just want one rectangle.
  color <- "#c6c2e2"
  line_width <- 2
  rect(120, 340, 180, 410, col = color, lwd = line_width)

  # Subtitle
  mtext("Subtitle: One Rectangle")
  ```

### Let's Go!

From now on, let's go all out to draw the geometry of overlapping patches while
referring back to the code example as a reference.

First, I want to communicate the patch overlap by means of transparent
rectangles. According to
https://stackoverflow.com/questions/18056146/how-to-add-a-transparent-rectangle-to-a-r-boxplot-plot#,
the alpha blending will do the job:
```
rect(x0, y0, x1, y1, col = rgb(0, 0, 1, alpha = 0.2))
```

To make our work manageable and easily debuggable, we will decouple the geometry
data and the drawing.

#### Geometry Data

SIFT divides the image patch into a grid $N \times N$ of smaller patches. Let
us define the sequence of indices.

```{r}
N <- 4
j <- 0:(N - 1)
i <- 0:(N - 1)
```

The patch center is:
```{r}
x <- 0
y <- 0
```

Each subpatch $(i, j)$ has their center at the following grid coordinates:
```{r}
xi <- i - (N - 1) / 2
yj <- j - (N - 1) / 2
```

```{r, echo = FALSE}
xi
yj
```

The patch region is exactly
```{r}
region_domain_x <- c(-(N-1)/2 - 1, (N-1)/2 + 1)
region_domain_y <- c(-(N-1)/2 - 1, (N-1)/2 + 1)
```

```{r, echo = FALSE}
region_domain_x
region_domain_y
```

#### Geometry Rendering
Let's now move onto the rendering.

The viewing domain will be slightly larger than the patch region:

```{r}
x_view_domain <- c(region_domain_x[1] - 1, region_domain_x[2] + 1)
y_view_domain <- c(region_domain_y[1] - 1, region_domain_y[2] + 1)
```

```{r, echo = FALSE}
x_view_domain
y_view_domain
```

##### Communicating the Pitfalls Due to the Lack of Overlap

```{r}
op <- par(bg = "#bfd8d8", pty="s")
plot(x_view_domain, y_view_domain, type = "n", xlab = "x", ylab = "y",
     main = "SIFT Anatomy")

# Cosmetics.
r <- 0.5
line_width <- 0.5

# `rect` actually renders a batch of rectangles.
for (x in xi) {
  for (y in yj) {
    color <- rgb(0.8, 0.8, 0.8, alpha = 0.5)
    rect(x - r, y - r, x + r, y + r,
         col = color,
         lwd = line_width)
  }
}

# Image patch center.
points(0, 0, col="red")

# Patch centers.
for (x in xi) {
  for (y in yj) {
    points(x, y, col = "blue")
  }
}

rect(xi[1] - r, yj[4] - r, xi[1] + r, yj[4] + r,
     col = rgb(1, 0, 0, alpha = 0.2),
     lwd = line_width)
rect(xi[2] - r, yj[4] - r, xi[2] + r, yj[4] + r,
     col = rgb(0, 1, 0, alpha = 0.2),
     lwd = line_width)
rect(xi[1] - r, yj[3] - r, xi[1] + r, yj[3] + r,
     col = rgb(0, 0, 1, alpha = 0.2),
     lwd = line_width)
rect(xi[2] - r, yj[3] - r, xi[2] + r, yj[3] + r,
     col = rgb(0, 1, 1, alpha = 0.2),
     lwd = line_width)

points(-0.8, 1.1, col="red",
       pch="+",  # I want a "+" shape
       cex=2)    # Larger size please


mtext("Without Overlapping")
```

##### Communicating about the Overlapping

Now with overlapping

```{r}
library(grid)
library(berryFunctions)

op <- par(bg = "#bfd8d8", pty="s")
plot(x_view_domain, y_view_domain, type = "n", xlab = "x", ylab = "y",
     main = "SIFT Anatomy")

grid(lwd = 1)

# Cosmetics.
color <- rgb(0.8, 0.8, 0.8, alpha = 0.2)
r <- 1.
line_width <- 0.5

# `rect` actually renders a batch of rectangles.
for (x in xi) {
  for (y in yj) {
    roundedRect(x - r, y - r, x + r, y + r, rounding = 0.25,
                col = color,
                lwd = line_width)
  }
}

# Image patch center.
points(0, 0, col="magenta")

# Patch centers.
for (x in xi) {
  for (y in yj) {
    points(x, y, col = "slateblue")
  }
}

roundedRect(xi[1] - r, yj[4] - r, xi[1] + r, yj[4] + r,
            rounding = 0.25,
            col = rgb(1, 0, 0, alpha = 0.2),
            lwd = line_width)
roundedRect(xi[2] - r, yj[4] - r, xi[2] + r, yj[4] + r,
            rounding = 0.25,
            col = rgb(0, 1, 0, alpha = 0.2),
            lwd = line_width)
roundedRect(xi[1] - r, yj[3] - r, xi[1] + r, yj[3] + r,
            rounding = 0.25,
            col = rgb(0, 0, 1, alpha = 0.2),
            lwd = line_width)
roundedRect(xi[2] - r, yj[3] - r, xi[2] + r, yj[3] + r,
            rounding = 0.25,
            col = rgb(0, 1, 1, alpha = 0.2),
            lwd = line_width)
points(-0.8, 1.1, col="red",
       pch="+",  # I want a "+" shape
       cex=2)    # Larger size please

mtext("With Overlapping")
```

#### Animation

Animating the drawing would communicate better my point in about the overlapping
patches.

TODO: explore.

1. Move the keypoint center and update the drawing.
2. Illustrate the overlapping by increasing the radius of each patch $(i, j)$.
